/**
 * 0ê³¼ 1ë¡œ ì´ë£¨ì–´ì§„ 2^n x 2^n í¬ê¸°ì˜ 2ì°¨ì› ì •ìˆ˜ ë°°ì—´ì´ ìˆë‹¤.
 * ì´ë¥¼ ì¿¼ë“œ íŠ¸ë¦¬ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì••ì¶•í•˜ê³ ì í•œë‹¤.
 * 1. ì••ì¶•í•˜ê³ ì í•˜ëŠ” íŠ¹ì • ì˜ì—­ S
 * 2. S ë‚´ë¶€ì— ìˆëŠ” ëª¨ë“  ìˆ˜ê°€ ê°™ì€ ê°’ì´ë¼ë©´,
 *    Së¥¼ í•´ë‹¹ ìˆ˜ í•˜ë‚˜ë¡œ ì••ì¶•í•œë‹¤.
 * 3. ì•„ë‹ˆë©´, Së¥¼ 4ê°œì˜ ê· ì¼í•œ ì •ì‚¬ê°í˜• ì˜ì—­ìœ¼ë¡œ ìª¼ê°  ë’¤,
 *    ê° ì •ì‚¬ê°í˜• ì˜ì—­ì— ëŒ€í•´ ì••ì¶•ì„ ì‹œë„í•œë‹¤.
 *
 * @param {*} arr
 * @returns ë°°ì—´ì— ìµœì¢…ì ìœ¼ë¡œ ë‚¨ì€ 0ê³¼ 1ì˜ ê°œìˆ˜
 *
 * ### ë¦¬ë·°
 * - í’€ì´ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
 *   ë¨¼ì € í•´ë‹¹ ì •ì‚¬ê°í˜•ì˜ ëª¨ë“  ìˆ«ìê°€ ë™ì¼í•œì§€ í™•ì¸í•œë‹¤.
 *   ë§Œì•½ ë™ì¼í•˜ë‹¤ë©´, answerì— í•´ë‹¹ ìˆ«ìì˜ ê°œìˆ˜ë¥¼ ëŠ˜ë ¤ì¤€ë‹¤.
 *   ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, í•´ë‹¹ ì •ì‚¬ê°í˜•ì„ 4ë“±ë¶„ìœ¼ë¡œ ë‚˜ëˆˆ ë’¤,
 *   ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.
 *
 * - ì •ì‚¬ê°í˜•ì„ ì–´ë–»ê²Œ 4ë“±ë¶„ìœ¼ë¡œ ë‚˜ëˆŒ ê²ƒì¸ì§€ë¥¼ ì˜¤ë«ë™ì•ˆ ê³ ë¯¼í–ˆë‹¤. ğŸ¤”
 *   ì²˜ìŒì—ëŠ”, ì •ì‚¬ê°í˜•ì˜ ì‹œì‘ ì§€ì ê³¼ ë§ˆì§€ë§‰ ì§€ì ì„ ì €ì¥í•˜ê³ , ê·¸ì— ëŒ€í•œ ì¤‘ê°„ ì§€ì ì„ ì°¾ì•˜ë‹¤.
 *   ê·¸ëŸ¬ë‚˜, ì •ì‚¬ê°í˜•ì˜ í¬ê¸°ë¥¼ ì•ˆë‹¤ë©´ ê³„ì‚° ë¡œì§ì´ í›¨ì”¬ ê°„ë‹¨í•´ì§ì„ ê¹¨ë‹«ê³  ì½”ë“œë¥¼ ìˆ˜ì •í–ˆë‹¤. ğŸ¤—
 *
 * - ì²˜ìŒ ì½”ë“œê°€ í‹€ë ¸ë˜ ì´ìœ ëŠ”,
 *   ì •ì‚¬ê°í˜•ì„ 4ë“±ë¶„í•  ë•Œ,
 *   ì¤‘ê°„ ì§€ì ì„ Rì˜ ê¸°ì¤€ìœ¼ë¡œ êµ¬í•œ ë’¤, ì´ë¥¼ Cì— ì ìš©í–ˆê¸° ë•Œë¬¸ì´ë‹¤. ğŸ˜…
 *
 * - ë‹¤ë¥¸ í’€ì´ ë°©ì‹ ì¤‘,
 *   ë°°ì—´ì˜ ë²”ìœ„ê°€ 2^nì´ê¸° ë•Œë¬¸ì—,
 *   sizeì˜ ì ˆë°˜ì„ êµ¬í•  ë•Œ "size >>= 1"ë¡œ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤.
 *
 *   ì°¸ê³ ë¡œ, ~~(n/2)ì™€ parseInt(n/2)ëŠ” Math.floor(n/2)ì™€ ë™ì¼í•˜ì§€ë§Œ,
 *   ëª…í™•í•œ ê±¸ ì¢‹ì•„í•´ì„œ Math.floorë¥¼ ì‚¬ìš©í–ˆë‹¤!
 */

function solution(arr) {
    const answer = [0, 0];
    countZeroAndOne(new Square([0, 0], arr.length));

    return answer;

    function countZeroAndOne(square) {
        if (square.isAllSameNumber(arr)) {
            const number = arr[square.point[0]][square.point[1]];
            answer[number]++;
            return;
        }

        square.divideIntoFourParts().forEach(countZeroAndOne);
    }
}

class Square {
    constructor(point, size) {
        this.point = point;
        this.size = size;
    }

    isAllSameNumber(arr) {
        const [R, C] = this.point;
        for (let r = R; r < R + this.size; r++) {
            for (let c = C; c < C + this.size; c++) {
                if (arr[r][c] !== arr[R][C]) return false;
            }
        }
        return true;
    }

    divideIntoFourParts() {
        const [R, C] = this.point;
        const halfSize = Math.floor(this.size / 2);

        return [
            [R, C],
            [R, C + halfSize],
            [R + halfSize, C],
            [R + halfSize, C + halfSize],
        ].map(point => new Square(point, halfSize));
    }
}

/****** TEST CASE *******/

console.log(
    solution([
        [1, 1, 0, 0],
        [1, 0, 0, 0],
        [1, 0, 0, 1],
        [1, 1, 1, 1],
    ]),
);

console.log(
    solution([
        [1, 1, 1, 1, 1, 1, 1, 1],
        [0, 1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 1, 1, 1, 1],
        [0, 1, 0, 0, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 1, 0, 0, 1],
        [0, 0, 0, 0, 1, 1, 1, 1],
    ]),
);
