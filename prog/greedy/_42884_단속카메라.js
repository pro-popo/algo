/**
 * 고속도로를 이용하는 모든 차량이
 * 단속용 카메라를 한 번은 만나도록 카메라를 설치하자.
 *
 * @param {*} routes 차량의 경로 [진입지점, 나간지점] -30_000~30_000 / 차량 1~10_000
 * @returns 최소 몇대의 카메라를 설치해야 하는가
 *
 * ### 리뷰
 * - 풀이 방식은 다음과 같다.
 *   포인트는, routes간의 교차점 중 최댓값을 구해 카메라 설치 여부를 결정하는 것이다.
 *
 *   먼저, routes를 진입지점의 오름차순으로 정렬한다.
 *   만약 진입지점이 같다면, 나간지점의 오름차순으로 정렬한다.
 *   그 다음 routes를 순회하여,
 *   해당 차량이 현재 최대 멀리 설치할 수 있는 카메라 위치(camera)에 지나가는지 검사한다.
 *   (즉, camera는 routes 간의 교차점 중 최댓값을 의미한다.)
 *   만약 지나간다면, 카메라 위치(camera)와 해당 차량의 나간지점 중 최솟값으로 카메라 위치를 업데이트 한다.
 *   그게 아니면, 해당 차량의 나간지점에 새로운 카메라를 설치한다.
 *
 * - 다른 풀이에서는,
 *   설치한 카메라를 관리하는 별도의 배열(cameras)을 생성했다.
 *   나간지점의 오름차순으로 정렬한 뒤,
 *   해당 차량의 route 범위에서 설치된 카메라가 있는지 검사하여 카메라 설치 여부를 결정한다.
 *
 * - 또 다른 풀이에서는,
 *   나간지점의 오름차순으로 정렬한 뒤,
 *   camera를 나간지점에 설치한다.
 *   만약 진입지점이 camera보다 클 경우, 해당 경로의 나간지점에 새로운 카메라를 설치한다.
 *
 *   기준점을 잘못 생각했다...!
 *   굳이 진입지점으로 정렬할 필요없이, 나간지점으로만 오름차순해도 충분하다는 것을 깨달았다. 😂
 */

function solution(routes) {
    routes.sort(ASC);

    let answer = 0;
    let camera = -30_001;
    routes.forEach(([start, end]) => {
        if (start > camera) {
            camera = end;
            answer++;
        }
    });
    return answer;
}

const ASC = ([, endA], [, endB]) => {
    return endA - endB;
};

console.log(
    solution([
        [-20, -15],
        [-20, -10],
        [-14, -5],
        [-5, -3],
    ]), //2
);
console.log(
    solution([
        [-20, 50],
        [10, 50],
        [20, 30],
        [30, 50],
        [50, 60],
    ]), // 2
);
