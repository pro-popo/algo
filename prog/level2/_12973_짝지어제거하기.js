/**
 * 짝지어 제거하기는 알파벳 소문자로 이루어진 문자열을 가지고 시작한다.
 * 먼저, 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾는다.
 * 그 다음, 그 둘을 제거한 뒤 앞뒤로 문자열을 이어 붙인다.
 * 이 과정을 반복하여 문자열을 모두 제거한다면 짝지어 제거하기가 종료된다.
 * 
 * 이러한 짝지어 제거하기를 성공적으로 수행할 수 있으면 1, 아닌 경우는 0을 반환한다.
 * 
 * @param {string} s - 문자열 (~1,000,000)
 * @return - 짝지어 제거하기를 성공적으로 수행할 수 있는지에 대한 여부
 * 
 * ### 리뷰
 * - 풀이 방식은 다음과 같다.
 *   스택 자료구조를 활용하여 문제를 풀 수 있다.
 * 
 *   문자열을 순회하여,
 *   스택이 비어있을 경우, 현재 문자를 스택에 push한다.
 *   비어있지 않을 경우, 스택에서 문자 하나를 pop하여 현재 문자와 동일한지 비교한다.
 *   이때, 두 문자가 동일할 경우, 그대로 두 문자를 제거한다.
 *   반면에 두 문자가 동일하지 않을 경우, 두 문자를 순서대로 스택에 저장한다.
 * 
 *   위 과정을 마친 후, 
 *   스택이 비어있는 경우에는 1, 아닌 경우에는 0을 반환한다.
 * 
 * - 처음에는,
 *   문자열을 순회하여 현재 문자가 이전 문자와 동일한 경우 제거해 주었으며,
 *   더이상 제거한 문자가 없을 때까지 위 과정을 반복했다.
 *   그러나 효율성 문제에서 시간초과가 발생했다. 😂
 */

function solution(s) {
    const stack = [];
    for (let i = 0; i < s.length; i++) {
        const current = s[i];
        if (!stack.length) {
            stack.push(current);
            continue;
        }

        const pre = stack.pop();
        if(pre === current) continue;
        stack.push(pre, current);
    }

    return stack.length ? 0 : 1;
}

/****** TEST CASE *******/

console.log(solution("baabaa"))

