/**
 * 가로 길이가 2, 세로 길이가 1인 직사각형 모양의 타일이 있다.
 * 이 타일을 이용하여, 세로가 2이고 가로가 n인 바닥을 가득 채우고자 한다.
 * 직사각형 모양의 타일은 가로 혹은 세로로 배치할 수 있다.
 * 이때 가로가 n인 바닥을 채우는 방법의 수를 구하자.
 *
 * @param {*} n - 바닥의 가로 길이 (60_000)
 * @returns - 타일로 바닥을 채우는 방법의 수
 *            이때, 1_000_000_007로 나눈 나머지를 반환한다.
 *
 * ### 리뷰
 * - 풀이 방식은 다음과 같다.
 *   가로가 n인 바닥을 채우는 방법의 수는,
 *   n=1인 경우, 1
 *   n=2인 경우, 2
 *   n=3인 경우, 3
 *   n=4인 경우, 5
 *   n=5인 경우, 8과 같다.
 *   이때, n이 증가할수록 방법의 수는 피보나치의 수와 동일한 것을 확인할 수 있다.
 *
 * - n의 크기가 최대 60_000이기 때문에,
 *   피보나치의 수를 구할 때 재귀를 사용할 경우, Stack Overflow가 발생한다.
 *   따라서 재귀가 아닌, 단순 반복문으로 구해야한다.
 *
 * - 동일한 풀이 방식인데도 불구하고,
 *   효율성에서 시간초과가 발생한 경우는 다음과 같다.
 *   1. 구조 분해 할당으로 0, 1번째 값을 초기화 한 경우 => [dp[0], dp[1]] = [1, 1];
 *   2. dp를 [1, 1]로 초기화한 경우
 *   3. 피보나치를 구하는 로직을 함수로 추출한 경우
 *   4. 배열이 아닌, 두 개의 변수를 가지고 값을 계산한 경우
 *   위와 같은 방식 또는 계산식이 더 많은 풀이가 존재했지만, 나와 다르게 전부 통과한 풀이다.😅
 */

function solution(n) {
    return fibonacci(n);
}

function fibonacci(n) {
    const dp = [1, 1];

    for (let i = 2; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1_000_000_007;
    }

    return dp[n];
}

/****** TEST CASE *******/

console.log(solution(60_000));
